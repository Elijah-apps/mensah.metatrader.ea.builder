# mql5_generator.py
class MQL5Generator:
    @staticmethod
    def generate_ea(blocks_xml, strategy_name):
        """Convert Blockly XML to complete MQL5 EA"""
        # Parse blocks and generate MQL5 code sections
        init_code = MQL5Generator._generate_init_code()
        tick_code = MQL5Generator._generate_tick_code(blocks_xml)
        indicator_code = MQL5Generator._generate_indicator_code(blocks_xml)
        
        # Combine into complete EA
        template = f"""
//+------------------------------------------------------------------+
//| {strategy_name}.mq5                                             |
//| Generated by EA Builder                                          |
//+------------------------------------------------------------------+
#property copyright "Generated by EA Builder"
#property version   "1.00"
#property strict

{indicator_code}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{{
    {init_code}
    return(INIT_SUCCEEDED);
}}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{{
}}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{{
    {tick_code}
}}
"""
        return template

    @staticmethod
    def _generate_tick_code(blocks_xml):
        """Generate trading logic for OnTick()"""
        # Parse blocks and convert to MQL5
        # This would be more sophisticated in a real implementation
        return """
    // Check for new bar
    static datetime last_bar_time = 0;
    datetime current_bar_time = iTime(_Symbol, _Period, 0);
    if(last_bar_time == current_bar_time) return;
    last_bar_time = current_bar_time;
    
    // Trading logic goes here
    double ma_fast = iMA(_Symbol, _Period, 10, 0, MODE_SMA, PRICE_CLOSE, 0);
    double ma_slow = iMA(_Symbol, _Period, 20, 0, MODE_SMA, PRICE_CLOSE, 0);
    
    if(ma_fast > ma_slow && !PositionSelect(_Symbol)) {
        // Buy signal
        MqlTradeRequest request = {0};
        request.action = TRADE_ACTION_DEAL;
        request.symbol = _Symbol;
        request.volume = 0.1;
        request.type = ORDER_TYPE_BUY;
        request.price = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
        request.deviation = 5;
        request.type_filling = ORDER_FILLING_FOK;
        
        OrderSend(request);
    }
    """

    @staticmethod
    def _generate_indicator_code(blocks_xml):
        """Generate indicator calculations"""
        return """
// Custom indicator calculations
double CalculateCustomIndicator() {
    return iRSI(_Symbol, _Period, 14, PRICE_CLOSE, 0);
}
"""

class MQL5Generator:
    @staticmethod
    def generate_ea(blocks_xml, strategy_name):
        """Convert Blockly XML to complete MQL5 EA with advanced features"""
        try:
            # Parse blocks and generate MQL5 code sections
            init_code = MQL5Generator._generate_init_code()
            tick_code = MQL5Generator._generate_tick_code(blocks_xml)
            indicator_code = MQL5Generator._generate_indicator_code(blocks_xml)
            helper_functions = MQL5Generator._generate_helper_functions()
            input_parameters = MQL5Generator._generate_input_parameters(blocks_xml)
            
            # Combine into complete EA
            template = f"""
//+------------------------------------------------------------------+
//| {strategy_name}.mq5                                             |
//| Generated by EA Builder                                          |
//+------------------------------------------------------------------+
#property copyright "Generated by EA Builder"
#property version   "1.00"
#property strict

// Input parameters
{input_parameters}

// Global variables
{indicator_code}

// Helper functions
{helper_functions}

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{{
    {init_code}
    return(INIT_SUCCEEDED);
}}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{{
    // Clean up
    Print("EA deinitialized with reason: ", reason);
}}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{{
    {tick_code}
}}
"""
            return template
        except Exception as e:
            print(f"Error generating EA: {e}")
            return None

    @staticmethod
    def _generate_input_parameters(blocks_xml):
        """Generate input parameters for the EA"""
        return """
// Trading parameters
input double LotSize = 0.1;               // Base lot size
input int StopLoss = 50;                  // Stop loss in points
input int TakeProfit = 100;               // Take profit in points
input double RiskPercent = 2.0;           // Risk percentage per trade
input int MaxOpenPositions = 3;           // Maximum open positions
input int Slippage = 3;                   // Allowed slippage in points

// Strategy parameters
input int FastMAPeriod = 10;              // Fast MA period
input int SlowMAPeriod = 20;              // Slow MA period
input int RSIPeriod = 14;                 // RSI period
input double RSIOverbought = 70.0;        // RSI overbought level
input double RSIOversold = 30.0;          // RSI oversold level

// Time filters
input string TradeStartTime = "09:00";     // Trading start time
input string TradeEndTime = "17:00";       // Trading end time
input bool Monday = true;                 // Trade on Monday
input bool Tuesday = true;                // Trade on Tuesday
input bool Wednesday = true;              // Trade on Wednesday
input bool Thursday = true;               // Trade on Thursday
input bool Friday = true;                 // Trade on Friday
"""

    @staticmethod
    def _generate_tick_code(blocks_xml):
        """Generate advanced trading logic for OnTick()"""
        return """
    // Check for new bar
    static datetime last_bar_time = 0;
    datetime current_bar_time = iTime(_Symbol, _Period, 0);
    if(last_bar_time == current_bar_time) return;
    last_bar_time = current_bar_time;
    
    // Check trading hours
    if(!IsTradingTime()) return;
    
    // Check max positions
    if(CountOpenPositions() >= MaxOpenPositions) return;
    
    // Calculate indicators
    double ma_fast = iMA(_Symbol, _Period, FastMAPeriod, 0, MODE_SMA, PRICE_CLOSE, 0);
    double ma_slow = iMA(_Symbol, _Period, SlowMAPeriod, 0, MODE_SMA, PRICE_CLOSE, 0);
    double rsi = iRSI(_Symbol, _Period, RSIPeriod, PRICE_CLOSE, 0);
    
    // Calculate dynamic support/resistance
    double support = CalculateSupport();
    double resistance = CalculateResistance();
    double current_price = SymbolInfoDouble(_Symbol, SYMBOL_BID);
    
    // Calculate volatility-based position sizing
    double atr = iATR(_Symbol, _Period, 14, 0);
    double dynamic_lot_size = CalculatePositionSize(atr);
    
    // Check entry conditions with multiple factors
    if(ma_fast > ma_slow && 
       rsi < RSIOversold && 
       current_price > support && 
       current_price < resistance * 0.98) 
    {
        // Buy signal with range management
        double sl = support - StopLoss * _Point;
        double tp = current_price + TakeProfit * _Point;
        
        // Execute trade with loop for multiple attempts
        for(int attempt = 0; attempt < 3; attempt++) 
        {
            if(SendOrder(ORDER_TYPE_BUY, dynamic_lot_size, current_price, sl, tp)) 
            {
                Print("Buy order executed at ", current_price);
                break;
            }
            else 
            {
                Print("Order attempt ", attempt+1, " failed. Retrying...");
                Sleep(1000);
            }
        }
    }
    
    // Check for exit conditions
    CheckExitConditions();
"""

    @staticmethod
    def _generate_indicator_code(blocks_xml):
        """Generate advanced indicator calculations with custom indicators"""
        return """
// Custom indicator calculations
double CalculateSupport() {
    // Calculate support using recent lows
    double low1 = iLow(_Symbol, _Period, 1);
    double low2 = iLow(_Symbol, _Period, 2);
    double low3 = iLow(_Symbol, _Period, 3);
    return MathMin(MathMin(low1, low2), low3);
}

double CalculateResistance() {
    // Calculate resistance using recent highs
    double high1 = iHigh(_Symbol, _Period, 1);
    double high2 = iHigh(_Symbol, _Period, 2);
    double high3 = iHigh(_Symbol, _Period, 3);
    return MathMax(MathMax(high1, high2), high3);
}

double CalculateVolatilityIndex(int period=14) {
    // Custom volatility indicator
    double sum = 0;
    for(int i = 0; i < period; i++) {
        sum += MathAbs(iClose(_Symbol, _Period, i) - iOpen(_Symbol, _Period, i));
    }
    return sum / period / _Point;
}

double CalculateCustomMA(int period, int shift=0) {
    // Custom moving average with different calculation
    double sum = 0;
    for(int i = shift; i < shift + period; i++) {
        sum += (iHigh(_Symbol, _Period, i) + iLow(_Symbol, _Period, i)) / 2;
    }
    return sum / period;
}
"""

    @staticmethod
    def _generate_helper_functions():
        """Generate helper functions for trading operations"""
        return """
//+------------------------------------------------------------------+
//| Position management functions                                   |
//+------------------------------------------------------------------+
int CountOpenPositions() {
    int count = 0;
    for(int i = PositionsTotal()-1; i >= 0; i--) {
        if(PositionGetSymbol(i) == _Symbol) {
            count++;
        }
    }
    return count;
}

bool SendOrder(ENUM_ORDER_TYPE orderType, double lotSize, double price, double sl, double tp) {
    MqlTradeRequest request = {0};
    MqlTradeResult result = {0};
    
    request.action = TRADE_ACTION_DEAL;
    request.symbol = _Symbol;
    request.volume = lotSize;
    request.type = orderType;
    request.price = price;
    request.sl = sl;
    request.tp = tp;
    request.deviation = Slippage;
    request.type_filling = ORDER_FILLING_FOK;
    
    if(OrderSend(request, result)) {
        if(result.retcode == TRADE_RETCODE_DONE) {
            return true;
        }
    }
    Print("OrderSend failed with error: ", GetLastError());
    return false;
}

double CalculatePositionSize(double atr) {
    // Calculate position size based on risk and volatility
    double accountBalance = AccountInfoDouble(ACCOUNT_BALANCE);
    double riskAmount = accountBalance * RiskPercent / 100.0;
    double pointValue = SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE);
    
    if(pointValue == 0) return LotSize;
    
    double lots = riskAmount / (atr * pointValue);
    lots = NormalizeDouble(lots, 2);
    
    // Apply lot size constraints
    double minLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MIN);
    double maxLot = SymbolInfoDouble(_Symbol, SYMBOL_VOLUME_MAX);
    
    lots = MathMax(lots, minLot);
    lots = MathMin(lots, maxLot);
    
    return lots;
}

void CheckExitConditions() {
    // Check exit conditions for all open positions
    for(int i = PositionsTotal()-1; i >= 0; i--) {
        if(PositionGetSymbol(i) == _Symbol) {
            ulong ticket = PositionGetInteger(POSITION_TICKET);
            double profit = PositionGetDouble(POSITION_PROFIT);
            double openPrice = PositionGetDouble(POSITION_PRICE_OPEN);
            double currentPrice = PositionGetDouble(POSITION_PRICE_CURRENT);
            ENUM_POSITION_TYPE posType = (ENUM_POSITION_TYPE)PositionGetInteger(POSITION_TYPE);
            
            // Check trailing stop
            if(posType == POSITION_TYPE_BUY) {
                double newSl = currentPrice - StopLoss * _Point;
                double currentSl = PositionGetDouble(POSITION_SL);
                if(newSl > currentSl) {
                    ModifyPosition(ticket, currentSl, PositionGetDouble(POSITION_TP));
                }
            }
            // Similar for sell positions...
        }
    }
}

bool IsTradingTime() {
    MqlDateTime timeStruct;
    TimeCurrent(timeStruct);
    
    // Check day of week
    if((timeStruct.day_of_week == MONDAY && !Monday) ||
       (timeStruct.day_of_week == TUESDAY && !Tuesday) ||
       (timeStruct.day_of_week == WEDNESDAY && !Wednesday) ||
       (timeStruct.day_of_week == THURSDAY && !Thursday) ||
       (timeStruct.day_of_week == FRIDAY && !Friday)) {
        return false;
    }
    
    // Check time window
    int startHour, startMinute, endHour, endMinute;
    StringToTimeParts(TradeStartTime, startHour, startMinute);
    StringToTimeParts(TradeEndTime, endHour, endMinute);
    
    int currentMinutes = timeStruct.hour * 60 + timeStruct.min;
    int startMinutes = startHour * 60 + startMinute;
    int endMinutes = endHour * 60 + endMinute;
    
    return (currentMinutes >= startMinutes && currentMinutes <= endMinutes);
}

void StringToTimeParts(string timeStr, int &hour, int &minute) {
    string parts[];
    StringSplit(timeStr, ':', parts);
    if(ArraySize(parts) >= 2) {
        hour = (int)StringToInteger(parts[0]);
        minute = (int)StringToInteger(parts[1]);
    }
}

bool ModifyPosition(ulong ticket, double sl, double tp) {
    MqlTradeRequest request = {0};
    MqlTradeResult result = {0};
    
    request.action = TRADE_ACTION_SLTP;
    request.position = ticket;
    request.symbol = _Symbol;
    request.sl = sl;
    request.tp = tp;
    request.deviation = Slippage;
    
    return OrderSend(request, result);
}
"""

    @staticmethod
    def _generate_init_code():
        """Generate initialization code with error checking"""
        return """
    // Verify symbol information
    if(!SymbolInfoInteger(_Symbol, SYMBOL_TRADE_MODE_EXECUTION)) {
        Alert("Trading is disabled for ", _Symbol);
        return INIT_FAILED;
    }
    
    // Verify account information
    if(!AccountInfoInteger(ACCOUNT_TRADE_EXPERT)) {
        Alert("Automated trading is disabled in account settings");
        return INIT_FAILED;
    }
    
    // Verify terminal connection
    if(!TerminalInfoInteger(TERMINAL_CONNECTED)) {
        Alert("No internet connection");
        return INIT_FAILED;
    }
    
    // Print initialization information
    Print("EA initialized on ", _Symbol, " with timeframe ", EnumToString(_Period));
    Print("Account balance: ", AccountInfoDouble(ACCOUNT_BALANCE));
    Print("Server time: ", TimeCurrent());
"""
